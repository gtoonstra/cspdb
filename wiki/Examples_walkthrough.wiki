#summary Details how the examples work

= Introduction =

This page explains how the examples work and why the queries ended up as they are. It helps you to get a good idea about the internals of the engine and how you may optimize the problem statement and queries to gain better runtime characteristics.


= NQueens =

This is the easiest, so we start with this. See the script file "nqueens.csp", together with the database preparation file "nqueens.sql"

  * _init-knowledge_ connects to the database.
  * _add-iterative-domain_ is the same as _add-normal-domain_. It used to do something different. Adding a domain means that a new required variable is added to the tuples that you wish to form. In this example, a tuple is formed by a column and a row. This adds the "row" domain, the row number that must be assigned for the placement of a queen.
  * _add-normal-domain_ adds the column domain. The first parameter is the domain name (how you refer to values picked from that domain in the rest of the script). The other is the SQL query with which to query the values that can still be assigned during the progression.
  * _add-argument-to-domain_ assigns, in order, the values that have to be assigned to the open parameters in the SQL query for the domain query. If there are multiple variables, but they are to be filled by the same source variable, you should still duplicate the line.
  * _add-direct-assertion_ makes an "assertion" once a valid tuple is formed. This updates the state in the database, such that new domain queries after the tupelization return valid values from the domain.
  * _set-tuple-order_ defines the ordering mechanism for the produced tuples. In this case, order by column and if that is equal, by row next.
  * The goal is a standard "num tuples". This means that after, in this case, *8* tuples the solution is found. The standard engine continues to search other possible solutions until exhaustion.
  * The output graph file is a 'dot' file, which you can post-process with *graphviz*. This allows you to analyze the solutions further. This helps sometimes to find additional optimizations.
  * _go_ just starts the engine.

After every tupelization is made, the domain query is executed again. It needs to find, for the next tupelization, the valid values that can be assigned to the variable in question, depending on the progression/state of the solution so far. The columns are easy. This is the 
