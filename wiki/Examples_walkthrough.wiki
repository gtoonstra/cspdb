#summary Details how the examples work

= Introduction =

This page explains how the examples work and why the queries ended up as they are. It helps you to get a good idea about the internals of the engine and how you may optimize the problem statement and queries to gain better runtime characteristics.


= NQueens =

This is the easiest, so we start with this. See the script file "nqueens.csp", together with the database preparation file "nqueens.sql"

  * _init-knowledge_ connects to the database.
  * _add-iterative-domain_ is the same as _add-normal-domain_. It used to do something different. Adding a domain means that a new required variable is added to the tuples that you wish to form. In this example, a tuple is formed by a column and a row. This adds the "row" domain, the row number that must be assigned for the placement of a queen.
  * _add-normal-domain_ adds the column domain. The first parameter is the domain name (how you refer to values picked from that domain in the rest of the script). The other is the SQL query with which to query the values that can still be assigned during the progression.
  * _add-argument-to-domain_ assigns, in order, the values that have to be assigned to the open parameters in the SQL query for the domain query. If there are multiple variables, but they are to be filled by the same source variable, you should still duplicate the line.
  * _add-direct-assertion_ makes an "assertion" once a valid tuple is formed. This updates the state in the database, such that new domain queries after the tupelization return valid values from the domain. It is composed of two parts. One to update the state for the tupelization, the other to undo the state if the tupelization is invalid.
  * _set-tuple-order_ defines the ordering mechanism for the produced tuples. In this case, order by column and if that is equal, by row next.
  * The goal is a standard "num tuples". This means that after, in this case, *8* tuples the solution is found. The standard engine continues to search other possible solutions until exhaustion.
  * The output graph file is a 'dot' file, which you can post-process with *graphviz*. This allows you to analyze the solutions further. This helps sometimes to find additional optimizations.
  * _go_ just starts the engine.

After every tupelization is made, the domain query is executed again. It needs to find, for the next tupelization, the valid values that can be assigned to the variable in question, depending on the progression/state of the solution so far. The first one is usually easiest. 

In this case, the query says to find the id's of all columns that are not yet taken. The other domain then becomes constrained by the choice made in the first domain. During the execution, the tupelization makes a choice of a domain and only then executes the query for the next domain choices. Thus, we should assume that a column has already been chosen.

The next row is the result of a large time of analysis and try-outs on the problem. When using this engine, you'll notice how well you start understanding the problem itself and how the better understanding of the problem helps you to become smarter in finding a useful solution.

The second query starts by eliminating all values for rows, where the sum of the current column plus any row value already allocated to a row produces the same sum (this is a handy way to find all queens on a diagonal). The sum of the col+row is stored along in the database, which is a great example of how you can use extra generated variables to optimize queries further (so you don't need to recalculate them every time, they don't change per tuple/assignment).

The other clause looks at the other diagional. The final clause looks at rows that have already been chosen, so we don't assign the same row id twice.

The result is an nqueens solver that functionally works equivalent. Bench marks with C solutions show the performance is really poor however and it would be incredibly difficult to make this much more efficient due to the numerical nature of this problem and the relatively low number of variables.

= TSP =

I just noticed the SQL file for TSP is missing. Basically, this example is a TSP solver, not a TSP optimizer. In order to find the best route, you should do a query across a solution and find the solution where the total distance is shortest. If the number of cities is 12991, give this engine some time to run :). 

The queries work the same way. It selects any city not yet visited. Then it selects another city which is not equal to the one just chosen and which does not yet occur on any current route between cities.
